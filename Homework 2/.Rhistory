X1 = cps$education
X2 = c(cps$education, cps$hisp)
Y = l_earnings
Y = cps$l_earnings
X1 = cps$education
X2 = c(cps$education, cps$hisp)
Y = cps$l_earnings
X1 = cps$education
X2 = c(cps$education, cps$hisp)
b_hat1 = t(X1)%*%X
Y = cps$l_earnings
X1 = cps$education
X2 = c(cps$education, cps$hisp)
b_hat1 = t(X1)%*%X1
Y = cps$l_earnings
X1 = cps$education
X2 = c(cps$education, cps$hisp)
b_hat1 = solve(t(X1)%*%X1)%*%t(X1)%*%Y
View(reg1)
Y = cps$l_earnings
X1 = cps$education
X2 = c(cps$education, cps$hisp)
b_hat1 = solve(t(X1)%*%X1)%*%t(X1)%*%Y
Y = cps$l_earnings
X1 = cps$education
X2 = c(cps$education, cps$hisp)
b_hat1 = solve(t(X1)%*%X1)%*%t(X1)%*%Y
b_hat2 = solve(t(X2)%*%X2)%*%t(X2)%*%Y
Y = cps$l_earnings
X1 = cps$education
X2 = c(cps$education, cps$hisp)
b_hat1 = solve(t(X1)%*%X1)%*%t(X1)%*%Y
b_hat2 = solve(t(X2)%*%X2)%*%X2%*%Y
typeof(X2)
typeof(X2)
typeof(X2[1])
typeof(X2[1][1])
Y = as.matrix(cps$l_earnings)
X1 = as.matrix(cbind(1,cps$education))
X2 = c(cps$education, cps$hisp)
b_hat1 = solve(t(X1)%*%X1)%*%t(X1)%*%Y
View(X1)
Y = as.matrix(cps$l_earnings)
X1 = as.matrix(cbind(1,cps$education))
X2 = as.matrix(cps$education, cps$hisp)
b_hat1 = solve(t(X1)%*%X1)%*%t(X1)%*%Y
View(X2)
Y = as.matrix(cps$l_earnings)
X1 = as.matrix(cbind(1,cps$education))
X2 = as.matrix(cbind(cps$education, cps$hisp))
b_hat1 = solve(t(X1)%*%X1)%*%t(X1)%*%Y
Y = as.matrix(cps$l_earnings)
X1 = as.matrix(cbind(1,cps$education))
X2 = as.matrix(cbind(1, cps$education, cps$hisp))
b_hat1 = solve(t(X1)%*%X1)%*%t(X1)%*%Y
Y = as.matrix(cps$l_earnings)
X1 = as.matrix(cbind(1,cps$education))
X2 = as.matrix(cbind(1, cps$education, cps$hisp))
b_hat1 = solve(t(X1)%*%X1)%*%t(X1)%*%Y
b_hat2 = solve(t(X2)%*%X2)%*%t(X2)%*%Y
Y = as.matrix(cps$l_earnings)
X1 = as.matrix(cbind(1,cps$education))
X2 = as.matrix(cbind(1, cps$education, cps$hisp))
b_hat1 = solve(t(X1)%*%X1)%*%t(X1)%*%Y
b_hat2 = solve(t(X2)%*%X2)%*%t(X2)%*%Y
Y = as.matrix(cps$l_earnings)
X1 = as.matrix(cbind(1,cps$education))
X2 = as.matrix(cbind(1, cps$education, cps$hisp))
b_hat1 = solve(t(X1)%*%X1)%*%t(X1)%*%Y
b_hat2 = solve(t(X2)%*%X2)%*%t(X2)%*%Y
res_1 = as.matrix(Y-b_hat1[1]-b_hat1[2]*X[,2])
Y = as.matrix(cps$l_earnings)
X1 = as.matrix(cbind(1,cps$education))
X2 = as.matrix(cbind(1, cps$education, cps$hisp))
b_hat1 = solve(t(X1)%*%X1)%*%t(X1)%*%Y
b_hat2 = solve(t(X2)%*%X2)%*%t(X2)%*%Y
res_1 = as.matrix(Y-b_hat1[1]-b_hat1[2]*X1[,2])
Y = as.matrix(cps$l_earnings)
X1 = as.matrix(cbind(1,cps$education))
X2 = as.matrix(cbind(1, cps$education, cps$hisp))
b_hat1 = solve(t(X1)%*%X1)%*%t(X1)%*%Y
b_hat2 = solve(t(X2)%*%X2)%*%t(X2)%*%Y
res_1 = as.matrix(Y-b_hat1[1]-b_hat1[2]*X1[,2])
res_1
res_1-residuals(reg1)
Y = as.matrix(cps$l_earnings)
X1 = as.matrix(cbind(1,cps$education))
X2 = as.matrix(cbind(1, cps$education, cps$hisp))
b_hat1 = solve(t(X1)%*%X1)%*%t(X1)%*%Y
b_hat2 = solve(t(X2)%*%X2)%*%t(X2)%*%Y
res_1 = as.matrix(Y-b_hat1[1]-b_hat1[2]*X1[,2])
res_2 = as.matrix(Y-b_hat2[1]-b_hat2[2]*X2[,2]-b_hat2[3]*X2[,3])
#knitr::opts_chunk$set(echo = FALSE)
#knitr::opts_chunk$set(prompt = TRUE)
#hook1 <- function(x){ gsub("```\n*```r*\n*", "", x) }
# These lines improve formatting of output by removing blank space
hook2 <- function(x){ gsub("```\n+```\n", "", x) }
knitr::knit_hooks$set(document = hook2)
library(tidyverse)
cps <- read_tsv("https://www.ssc.wisc.edu/~bhansen/econometrics/cps09mar.txt",
col_names=c("age","female","hisp","education","earnings","hours","week","union","uncov","region","race","marital"))
cps <- mutate(cps,l_earnings=log(earnings/(hours*week)))
library(tidyverse, dplyr)
cps <- read_tsv("https://www.ssc.wisc.edu/~bhansen/econometrics/cps09mar.txt",
col_names=c("age","female","hisp","education","earnings","hours","week","union","uncov","region","race","marital"))
cps <- mutate(cps,l_earnings=log(earnings/(hours*week)))
reg1 = lm(l_earnings~education, data=cps)
reg1
reg2 = lm(l_earnings~education+hisp, data=cps)
reg2
typeof(residuals(reg1))
Y = as.matrix(cps$l_earnings)
X1 = as.matrix(cbind(1,cps$education))
X2 = as.matrix(cbind(1, cps$education, cps$hisp))
b_hat1 = solve(t(X1)%*%X1)%*%t(X1)%*%Y
b_hat2 = solve(t(X2)%*%X2)%*%t(X2)%*%Y
res_1 = as.matrix(Y-b_hat1[1]-b_hat1[2]*X1[,2])
res_2 = as.matrix(Y-b_hat2[1]-b_hat2[2]*X2[,2]-b_hat2[3]*X2[,3])
Y = as.matrix(cps$l_earnings)
X1 = as.matrix(cbind(1,cps$education))
X2 = as.matrix(cbind(1, cps$education, cps$hisp))
b_hat1 = solve(t(X1)%*%X1)%*%t(X1)%*%Y
b_hat2 = solve(t(X2)%*%X2)%*%t(X2)%*%Y
res_1 = as.matrix(Y-b_hat1[1]-b_hat1[2]*X1[,2])
res_2 = as.matrix(Y-b_hat2[1]-b_hat2[2]*X2[,2]-b_hat2[3]*X2[,3])
all.equal(res_1, my_res_1)
Y = as.matrix(cps$l_earnings)
X1 = as.matrix(cbind(1,cps$education))
X2 = as.matrix(cbind(1, cps$education, cps$hisp))
b_hat1 = solve(t(X1)%*%X1)%*%t(X1)%*%Y
b_hat2 = solve(t(X2)%*%X2)%*%t(X2)%*%Y
my_res_1 = as.matrix(Y-b_hat1[1]-b_hat1[2]*X1[,2])
my_res_2 = as.matrix(Y-b_hat2[1]-b_hat2[2]*X2[,2]-b_hat2[3]*X2[,3])
all.equal(res_1, my_res_1)
all.equal(res_1, my_res_1)
Y = as.matrix(cps$l_earnings)
X1 = as.matrix(cbind(1,cps$education))
X2 = as.matrix(cbind(1, cps$education, cps$hisp))
b_hat1 = solve(t(X1)%*%X1)%*%t(X1)%*%Y
b_hat2 = solve(t(X2)%*%X2)%*%t(X2)%*%Y
my_res_1 = as.matrix(Y-b_hat1[1]-b_hat1[2]*X1[,2])
my_res_2 = as.matrix(Y-b_hat2[1]-b_hat2[2]*X2[,2]-b_hat2[3]*X2[,3])
all.equal(res_1, my_res_1)
all.equal(res_2, my_res_2)
t(X1)%*%my_res_1
is.zero(t(X1)%*%my_res_1)
all.equal(t(X1)%*%my_res_1, as.matrix(0,2))
all.equal(t(X1)%*%my_res_1, as.matrix(rep(0,2)))
zeros = as.matrix(rep(0,2))
all.equal(t(X1)%*%my_res_1, zeros)
zeros_1 = as.matrix(rep(0,2))
all.equal(t(X1)%*%my_res_1, zeros_1)
zeros_2 = as.matrix(rep(0,3))
all.equal(t(X2)%*%my_res_2, zeros_2)
P = X1%*%solve(t(X1)%*%X1)%*%t(X1)
dim(X1%*%solve(t(X1)%*%X1)%*%t(X1))
gc()
P = X1%*%solve(t(X1)%*%X1)%*%t(X1)
P = X1%*%solve(t(X1)%*%X1)%*%t(X1)
sparse_X = head(X1, 1000)
P = sparse_X%*%solve(t(sparse_X)%*%sparse_X)%*%t(sparse_X)
sparse_X = head(X1, 1000)
P = sparse_X%*%solve(t(sparse_X)%*%sparse_X)%*%t(sparse_X)
dim(P)
sparse_X = head(X1, 100)
P = sparse_X%*%solve(t(sparse_X)%*%sparse_X)%*%t(sparse_X)
dim(P)
P*P
all.equal(P%*%sparse_X,sparse_X)
sparse_X = head(X1, 1000)
P = sparse_X%*%solve(t(sparse_X)%*%sparse_X)%*%t(sparse_X)
dim(P)
all.equal(P%*%sparse_X,sparse_X)
all.equal(P%*%P, P)
sparse_X = head(X1, 100)
P = sparse_X%*%solve(t(sparse_X)%*%sparse_X)%*%t(sparse_X)
dim(P)
all.equal(P%*%sparse_X,sparse_X)
all.equal(P%*%P, P)
M = diag(100)-P
dim(M)
zeros_m = as.matrix(0,100,2)
all.equal(M%*%sparse_X, zeros_m)
zeros_m = matrix(0,100,2)
all.equal(M%*%sparse_X, zeros_m)
#knitr::opts_chunk$set(echo = FALSE)
#knitr::opts_chunk$set(prompt = TRUE)
#hook1 <- function(x){ gsub("```\n*```r*\n*", "", x) }
# These lines improve formatting of output by removing blank space
hook2 <- function(x){ gsub("```\n+```\n", "", x) }
knitr::knit_hooks$set(document = hook2)
# Let's first build the regressions
reg_test = function(omega, index, n){
n = replace_func(index, n) # Use the replace function to build the dummy vector
errors = ifelse(n[1]==1, omega, 1) # Build the errors associated with the dummies
df = tibble(xx = n,
err = errors,
y = x+err)
reg = lm(y~x, data=df)
return(reg)
}
#knitr::opts_chunk$set(echo = FALSE)
#knitr::opts_chunk$set(prompt = TRUE)
#hook1 <- function(x){ gsub("```\n*```r*\n*", "", x) }
# These lines improve formatting of output by removing blank space
hook2 <- function(x){ gsub("```\n+```\n", "", x) }
knitr::knit_hooks$set(document = hook2)
library(tidyverse, dplyr, sandwich)
install.packages("sandwich")
library(tidyverse, dplyr, sandwich)
#knitr::opts_chunk$set(echo = FALSE)
#knitr::opts_chunk$set(prompt = TRUE)
#hook1 <- function(x){ gsub("```\n*```r*\n*", "", x) }
# These lines improve formatting of output by removing blank space
hook2 <- function(x){ gsub("```\n+```\n", "", x) }
knitr::knit_hooks$set(document = hook2)
library(tidyverse, dplyr, sandwich)
#knitr::opts_chunk$set(echo = FALSE)
#knitr::opts_chunk$set(prompt = TRUE)
#hook1 <- function(x){ gsub("```\n*```r*\n*", "", x) }
# These lines improve formatting of output by removing blank space
hook2 <- function(x){ gsub("```\n+```\n", "", x) }
knitr::knit_hooks$set(document = hook2)
library(tidyverse, dplyr, sandwich)
installed.packages("sandwich")
installed.packages("tidyverse")
install.packages("sandwich")
install.packages("Rtools")
library(tidyverse, dplyr, sandwich)
install.packages('sandwich')
install.packages('sandwich')
#knitr::opts_chunk$set(echo = FALSE)
#knitr::opts_chunk$set(prompt = TRUE)
#hook1 <- function(x){ gsub("```\n*```r*\n*", "", x) }
# These lines improve formatting of output by removing blank space
hook2 <- function(x){ gsub("```\n+```\n", "", x) }
knitr::knit_hooks$set(document = hook2)
library(tidyverse, dplyr, sandwich)
library(tidyverse, dplyr)
library(lmtest)
set.seed(42)
library(tidyverse, dplyr)
library(lmtest)
library(sandwich)
set.seed(42)
# Instantiate repetitions and grid of parameters for running simulations
num_reps=1000
param_list <- expand.grid(rep=1:num_reps, n=c(10,100,1000), pop_dist = c("N01", "N31", "N03"))
# Pass parameters to simulation
sim_out <- param_list %>%
mutate(results=pmap(param_list,sim_func)) %>%
unnest_wider(results)
# Create simulation function to generate results.
sim_func = function(rep, n, pop_dist){
dat <- tibble(xx = dist_list[[pop_dist]](n),
err = rnorm(n=n,0,1),
y=xx+err)
reg <- lm(y~xx, data=dat)
results <- list(beta_lm = coefficients(reg)[2], beta_ana = cov(x=dat$xx, y=dat$y)/var(x=dat$xx), SE = se <- sqrt(diag(vcov(reg))))
return(results)
}
# Instantiate repetitions and grid of parameters for running simulations
num_reps=1000
param_list <- expand.grid(rep=1:num_reps, n=c(10,100,1000), pop_dist = c("N01", "N31", "N03"))
# Pass parameters to simulation
sim_out <- param_list %>%
mutate(results=pmap(param_list,sim_func)) %>%
unnest_wider(results)
#knitr::opts_chunk$set(echo = FALSE)
#knitr::opts_chunk$set(prompt = TRUE)
#hook1 <- function(x){ gsub("```\n*```r*\n*", "", x) }
# These lines improve formatting of output by removing blank space
hook2 <- function(x){ gsub("```\n+```\n", "", x) }
knitr::knit_hooks$set(document = hook2)
library(tidyverse, dplyr)
library(lmtest)
library(sandwich)
# Set seed for repeatable results
set.seed(42)
# Create list of distributions of interest
dist_list = list(N01 = function(n) rlnorm(n,0,1),
N31 = function(n) rlnorm(n,3,1),
N03 = function(n) rlnorm(n,0,3))
# Create simulation function to generate results.
sim_func = function(rep, n, pop_dist){
dat <- tibble(xx = dist_list[[pop_dist]](n),
err = rnorm(n=n,0,1),
y=xx+err)
reg <- lm(y~xx, data=dat)
results <- list(beta_lm = coefficients(reg)[2], beta_ana = cov(x=dat$xx, y=dat$y)/var(x=dat$xx), SE = se <- sqrt(diag(vcov(reg))))
return(results)
}
# Instantiate repetitions and grid of parameters for running simulations
num_reps=1000
param_list <- expand.grid(rep=1:num_reps, n=c(10,100,1000), pop_dist = c("N01", "N31", "N03"))
# Pass parameters to simulation
sim_out <- param_list %>%
mutate(results=pmap(param_list,sim_func)) %>%
unnest_wider(results)
# Group and print relevant information
sim_print <- group_by(sim_out,n,pop_dist) %>%
mutate(mean_beta=mean( beta_lm)) %>%
ungroup() %>%
select(n,pop_dist,mean_beta) %>%
distinct() %>%
pivot_wider(names_from=pop_dist, values_from=mean_beta)
sim_print
# Group and print relevant information
sim_print.se <- group_by(sim_out,n,pop_dist) %>%
mutate(mean_SE=mean(SE)) %>%
ungroup() %>%
select(n,pop_dist,mean_SE) %>%
distinct() %>%
pivot_wider(names_from=pop_dist, values_from=mean_SE)
sim_print.se
View(sim_out)
# Create simulation function to generate results.
sim_func = function(rep, n, pop_dist){
dat <- tibble(xx = dist_list[[pop_dist]](n),
err = rnorm(n=n,0,1),
y=xx+err)
reg <- lm(y~xx, data=dat)
results <- list(beta_lm = coefficients(reg)[2], beta_ana = cov(x=dat$xx, y=dat$y)/var(x=dat$xx), SE = se <- sqrt(diag(vcov(reg)))[2])
return(results)
}
# Instantiate repetitions and grid of parameters for running simulations
num_reps=1000
param_list <- expand.grid(rep=1:num_reps, n=c(10,100,1000), pop_dist = c("N01", "N31", "N03"))
# Pass parameters to simulation
sim_out <- param_list %>%
mutate(results=pmap(param_list,sim_func)) %>%
unnest_wider(results)
# Group and print relevant information
sim_print <- group_by(sim_out,n,pop_dist) %>%
mutate(mean_beta=mean( beta_lm)) %>%
ungroup() %>%
select(n,pop_dist,mean_beta) %>%
distinct() %>%
pivot_wider(names_from=pop_dist, values_from=mean_beta)
sim_print
# Group and print relevant information
sim_print.se <- group_by(sim_out,n,pop_dist) %>%
mutate(mean_SE=mean(SE)) %>%
ungroup() %>%
select(n,pop_dist,mean_SE) %>%
distinct() %>%
pivot_wider(names_from=pop_dist, values_from=mean_SE)
sim_print.se
setwd("C:/Users/latha/School/UCD First Year Courses/ECN 240A/Homework 2")
# Create simulation function to generate results.
sim_func = function(rep, n, pop_dist){
dat <- tibble(xx = dist_list[[pop_dist]](n),
err = rnorm(n=n,0,1),
y=log(xx)+err)
reg <- lm(y~xx, data=dat)
results <- list(beta_lm = coefficients(reg)[2], beta_ana = cov(x=dat$xx, y=dat$y)/var(x=dat$xx), SE = se <- sqrt(diag(vcov(reg)))[2])
return(results)
}
# Instantiate repetitions and grid of parameters for running simulations
num_reps=1000
param_list <- expand.grid(rep=1:num_reps, n=c(10,100,1000), pop_dist = c("N01", "N31", "N03"))
# Pass parameters to simulation
sim_out <- param_list %>%
mutate(results=pmap(param_list,sim_func)) %>%
unnest_wider(results)
# Group and print relevant information
sim_print <- group_by(sim_out,n,pop_dist) %>%
mutate(mean_beta=mean( beta_lm)) %>%
ungroup() %>%
select(n,pop_dist,mean_beta) %>%
distinct() %>%
pivot_wider(names_from=pop_dist, values_from=mean_beta)
sim_print
# Group and print relevant information
sim_print.se <- group_by(sim_out,n,pop_dist) %>%
mutate(mean_SE=mean(SE)) %>%
ungroup() %>%
select(n,pop_dist,mean_SE) %>%
distinct() %>%
pivot_wider(names_from=pop_dist, values_from=mean_SE)
sim_print.se
# Create simulation function to generate results.
sim_func = function(rep, n, pop_dist){
dat <- tibble(xx = dist_list[[pop_dist]](n),
err = rnorm(n=n,0,1),
y=log(xx)+err)
reg <- lm(y~xx, data=dat)
results <- list(beta_lm = coefficients(reg)[2],
beta_ana = cov(x=dat$xx, y=dat$y)/var(x=dat$xx),
SE = se <- sqrt(diag(vcov(reg)))[2], Bias = bias(reg))
return(results)
}
# Instantiate repetitions and grid of parameters for running simulations
num_reps=1000
param_list <- expand.grid(rep=1:num_reps, n=c(10,100,1000), pop_dist = c("N01", "N31", "N03"))
# Pass parameters to simulation
sim_out <- param_list %>%
mutate(results=pmap(param_list,sim_func)) %>%
unnest_wider(results)
?bias
?bias()
y = rnrom(100)
y = rnorm(100)
x = rlnorm(100)
reg = lm(y~x)
bias(reg)
install.packages("simDesign")
install.packages("SimDesign")
library(tidyverse, dplyr)
library(lmtest)
library(sandwich)
library(SimDesign)
y = rnorm(100)
x = rlnorm(100)
reg = lm(y~x)
bias(reg)
bias(coefficients(reg))
bias(coefficients(reg)[2])
coefficients(reg)[2]
bias(coefficients(reg)[2], y)
y = rnorm(100)
x = rlnorm(100)
reg = lm(y~x)
bias(x, y)
y = rnorm(100)
x = rnorm(100)
reg = lm(y~x)
bias(x, y)
y = rnorm(100)
x = rnorm(100)
reg = lm(y~x)
bias(x, y)
y = rnorm(100)
x = rnorm(100)
reg = lm(y~x)
bias(x, y)
y = rnorm(100)
x = rnorm(100)
reg = lm(y~x)
bias(x, y)
y = rnorm(100)
x = rnorm(100)
reg = lm(y~x)
bias(x, y)
y = rnorm(100)
x = rlnorm(100)
reg = lm(y~x)
bias(x, y)
y = rnorm(100)
x = rlnorm(100)
reg = lm(y~x)
bias(x, y)
y = rnorm(100)
x = rlnorm(100)
reg = lm(y~x)
bias(x, y)
y = rnorm(100)
x = rlnorm(100)
reg = lm(y~x)
bias(x, y)
y = rnorm(100)
x = rlnorm(100)
reg = lm(y~x)
bias(x, y)
y = rnorm(100)
x = rlnorm(100)
reg = lm(y~x)
bias(x, y)
# Create simulation function to generate results.
sim_func = function(rep, n, pop_dist){
dat <- tibble(xx = dist_list[[pop_dist]](n),
err = rnorm(n=n,0,1),
y=log(xx)+err)
reg <- lm(y~xx, data=dat)
results <- list(beta_lm = coefficients(reg)[2],
beta_ana = cov(x=dat$xx, y=dat$y)/var(x=dat$xx),
SE = se <- sqrt(diag(vcov(reg)))[2], Bias = bias(df$xx, df$y))
return(results)
}
# Instantiate repetitions and grid of parameters for running simulations
num_reps=1000
param_list <- expand.grid(rep=1:num_reps, n=c(10,100,1000), pop_dist = c("N01", "N31", "N03"))
# Pass parameters to simulation
sim_out <- param_list %>%
mutate(results=pmap(param_list,sim_func)) %>%
unnest_wider(results)
# Create simulation function to generate results.
sim_func = function(rep, n, pop_dist){
dat <- tibble(xx = dist_list[[pop_dist]](n),
err = rnorm(n=n,0,1),
y=log(xx)+err)
reg <- lm(y~xx, data=dat)
results <- list(beta_lm = coefficients(reg)[2],
beta_ana = cov(x=dat$xx, y=dat$y)/var(x=dat$xx),
SE = se <- sqrt(diag(vcov(reg)))[2])
return(results)
}
# Instantiate repetitions and grid of parameters for running simulations
num_reps=1000
param_list <- expand.grid(rep=1:num_reps, n=c(10,100,1000), pop_dist = c("N01", "N31", "N03"))
# Pass parameters to simulation
sim_out <- param_list %>%
mutate(results=pmap(param_list,sim_func)) %>%
unnest_wider(results)
# Group and print relevant information
sim_print <- group_by(sim_out,n,pop_dist) %>%
mutate(mean_beta=mean( beta_lm)) %>%
ungroup() %>%
select(n,pop_dist,mean_beta) %>%
distinct() %>%
pivot_wider(names_from=pop_dist, values_from=mean_beta)
sim_print
